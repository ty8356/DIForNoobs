<!doctype html>
<html>
	<head>
		<title>DI For Noobs</title>
		<link rel="stylesheet" href="reveal/css/reveal.css">
		<link rel="stylesheet" href="reveal/css/theme/night.css">
		<link rel="stylesheet" href="reveal/lib/css/zenburn.css">
        <script src="reveal/lib/js/head.min.js"></script>
		<script src="reveal/js/reveal.js"></script>

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal/css/print/pdf.css' : 'reveal/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal" style="font-size: 38px;">
			<div class="slides">

                <section>
                    <h3>Dependency Injection for Noobs</h3>
                    <hr/>
                    Tyler Stephenson
                </section>
                
                <section>
                    <section>
                        <b>About Me</b>
                    </section>
                    <section>
                        <p>
                            Junior Associate .NET Developer at KiZAN Technologies
                            <br/>
                            <br/>
                            <br/>
                            Programming for almost two years
                        </p>
                        <aside class="notes">
                            (September 2015)
                        </aside>
                    </section>
                    <section>
                        <b>Find me on Twitter!</b><br/>
                        @ty8356
                    </section>
                </section>

                <section>
                    <section>
                        So my boss told me to learn about <b>Dependency Injection</b> because it allows for more <b>decoupled code</b>...
                    </section>
                    <section>
                        <p>Why the heck would I want to do that???
                        <br/>
                        <br/>
                        <div class="fragment">And what is Dependency Injection anyway???</div></p>
                    </section>
                    <section>
                        This will be specific to <b>.NET</b> using <b>C#</b>, but these ideas can be used elsewhere. 
                        <aside class="notes">
                            This presentation will be directed specifically at Dependency Injection in .NET using C#, but you can take these ideas and use them in most other frameworks and languages.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        So we've got a <b>problem</b>...
                        <aside class="notes">
                            So we have a problem... And I'm going to show you how to fix that problem... let's get started.
                            <br />
                            So there is a problem with Dependency Injection. But before we actually get into that problem, I want to make sure you have some kind of foundation of <i>what</i> Dependency Injection really is.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        Before we get into <b>Dependency Injection</b>, you need to know a couple things...
                        <aside class="notes">
                            Before we get into Dependency Injection, you have to know a couple things.
                            <br />
                            So, there are a couple of things you need to know before we get into dependency injection.
                        </aside>
                    </section>
                    <section>
                        <b>Interfaces<br/><br/>
                        <span class="fragment">Inversion of Control</b></span>
                        <aside class="notes">
                            Interfaces - What they are, how to use them, and how they can help you.
                            IoC - What it is, how to use it, how it can help you.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <b>Interfaces</b>
                    </section>
                    <section>
                        Programming to <b>interfaces</b> is good.
                        <aside class="notes">
                            So <b>why</b> is programming to an interface so good? What do I mean by that. Well, using interfaces can make your life easier.
                        </aside>
                    </section>
                    <section>
                        Allows you to <b>swap</b> classes in and out.<br/>
                        <span class="fragment">Simplifies <b>unit</b> and <b>integration</b> testing.</span><br/>
                        <span class="fragment">Makes code <b>versatile</b>.</span>
                        <aside class="notes">
                            Programming to an interface is good because it allows you to swap classes in and out based on application needs. 
                            Interfaces also allow for easier unit and integration testing, as you can swap the real class out for a mocked version.
                            Similar to a contract. By implementing an interface, you <b>must</b> have all functions defined.
                        </aside>
                    </section>
                    <section>
                        Let's look at an example...
                    </section>
                    <section>
                        This is an interface...
                        <span class="fragment"><pre><code data-trim data-noescape>
                            public interface InterfaceA
                            {
                                void A(string param);
                                int B();
                            }    
                        </code></pre></span>
                    </section>
                    <section>
                        ... and this is a class <b>implementing</b> that interface.
                        <span class="fragment"><pre><code data-trim data-noescape>
                            public class ClassA : InterfaceA
                            {
                                public void A(string param)
                                {
                                    // Code here
                                }

                                public int B()
                                {
                                    // Code here
                                }
                            }    
                        </code></pre></span>
                    </section>
                    <section>
                        How would I really use this?
                        <aside class="notes">
                            Talk about a personal experience.
                            This leads us to Inversion of Control, or IoC...
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <b>Inversion of Control</b>
                    </section>
                    <section>
                        Let's jump straight into some code...
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public void TestMethod()
                            {
                                string a = "Hello, world!";
                                // More code here
                            }
                        </code></pre>
                        <aside class="notes">
                            Let's say you have a function that does something like this. So we're clearly creating a new string called a and then potentially using it later on.
                            This isn't an incorrect thing to do. However, doing it this way could be really controlling with what exact string is being used.
                            It removes your ability to use any other string in place of the one you've created here. Inversion of Control can help us out with this.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public void TestMethod(string a)
                            {
                                // Code here
                            }
                        </code></pre>
                        <aside class="notes">
                            Here's virtually the same thing again, but this time we're using Inversion of Control. Now, we're giving whoever is calling the function the 
                            ability and the permission to pass through any string they can think of. This makes it the callers responsibility, and gives us the option of using a different string 
                            easily later down the road. 
                        </aside>
                    </section>
                    <section>
                        IoC <b>inverts</b> the <b>control</b>, so that the person calling the class can define how the class works.
                        <aside class="notes">
                            Basically, you can think of Inversion of Control as literally inverting the control to outside of the class. So whoever is calling the class, gets to decide how the class works.
                        </aside>
                    </section>
                    <section>
                        Dependency Injection
                        <aside class="notes">
                            This brings us to Dependency Injection.....<br/>
                            Now, whether you believe it or not, what we've just seen is actually <b>Dependency Injection</b>.<br/>
                            Let's take another look at what DI looks like..
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            var msg = "Hello, world!";
                            MethodA(msg);
                        </code></pre>
                        <aside class="notes">
                            Does this look familiar? This is what Dependency Injection looks like in code.<br/>
                            It's literally the act of passing a parameter into a class.<br/>
                            You are literally injecting the dependency by passing it through as a parameter, so now msg IS a dependency of MethodA.<br/>
                            We could even go as far as calling it Parameter Passing instead of Dependency Injection.<br/>
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        Let's dive deeper...
                        <aside class="notes">
                            So now that you know all of this stuff, let's dive a little deeper into Dependency Injection...
                        </aside>
                    </section>
                    <section>
                        A Different Look at DI.
                        <aside class="notes">
                            So far, we've looked at DI on a function level, passing variables into functions and what not.. Although this IS a form of DI, normally when you hear the 
                            term Dependency Injection, it's actually in reference to passing variables into <i>classes</i>, not functions.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            var msg = "Hello, world!";
                            var testService = new TestService(msg);
                        </code></pre>
                        <aside class="notes">
                            Notice that we're actually passing the msg variable into the class when we new it up!
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public TestService(string msg)
                            {
                                // Code here
                            }
                        </code></pre>
                        <aside class="notes">
                            On the other side of things, the class is capturing that variable in the constructor.
                            Because the constructor takes a string of msg, it now has a <b>dependency</b>, because it depends on that string being passed through.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public TestService(ClassA classA)
                            {
                                // Code here
                            }
                        </code></pre>
                        <aside class="notes">
                            To go even further, we can actually pass through entire classes to be used within the receiving class. That would look something like this.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        Interfaces, Inversion of Control, and Dependency Injection together.
                        <aside class="notes">
                            So let's take a look at everything we've seen so far, Interfaces, DI, and IoC working together to get a better picture of how we'll be using them in the future.<br/>
                            So by combining these three things, we get a great way to keep our code extremely maintainable as well as testable. Let's look at an example of Interfaces, IoC, and DI working together.
                        </aside>
                    </section>
                    <section>
                        <span class="fragment">Without an Interface</span>
                        <pre><code data-trim data-noescape>
                            public TestService(ClassA classA)
                            {
                                // Code here
                            }
                        </code></pre>
                        <span class="fragment">With an Interface
                            <pre><code data-trim data-noescape>
                            public TestService(IClassA classA)
                            {
                                // Code here
                            }
                        </code></pre></span>
                        <aside class="notes">
                            As of now, we've only looked at passing concrete type through the constructor. What if we used an interface instead? By using an interface instead of a concrete type, we're able to pass any class we want through the constructor, as long as it makes use of the correct interface.
                            So instead of writing something like this.....
                            we could write this.
                            So instead of passing through a ClassA, we can instead pass through the interface IClassA.
                            By using interfaces and IoC in this way, we open up a ton of options.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            var classA = new ClassA();
                            var testService = new TestService(classA)
                        </code></pre>
                        <aside class="notes">
                            On the other side of things, this is what calling that class would look like. We're able to pass through anything that implements the IClassA interface. As you know, this is Dependency Injection.
                        </aside>
                    </section>
                </section>
                
                <section>
                    <section>
                        <b>The Problem</b>
                        <aside class="notes">
                            Now.......... we can finally get to that problem we teased earlier....<br/>
                            So this whole inversion of control/dependency injection thing is great, right? We're able to reverse the responsibility to the outside of our class. What's not to love? 
                        </aside>
                    </section>
                    <section>
                        Multiple Dependencies
                        <aside class="notes">
                            Well, the problem comes in when we start to have multiple dependencies. Let's take a look at some examples.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Class with no dependencies
                            public class ClassA
                            {
                                public ClassA()
                                {

                                }
                            }
                        </code></pre>
                        <aside class="notes">
                            So let's start from square one. This is a class that has no dependencies. Just your plain old class, doing nothing special.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Newing up a class with no dependencies
                            var classA = new ClassA();
                        </code></pre>
                        <aside class="notes">
                            And newing this class up would look a little something like this. Because it has no dependencies, we don't need to worry about passing anything into it.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Class with a single dependency
                            public class ClassA
                            {
                                public ClassA(ClassB classB) 
                                {
                                    
                                }
                            }
                        </code></pre>
                        <aside class="notes">
                            Now, let's, again, look at a class with a single dependency, to refresh our minds.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Newing up a class with a single dependency
                            var classB = new ClassB();
                            var classA = new ClassA(classB);
                        </code></pre>
                        <aside class="notes">
                            So here, you can see that you have to create a new ClassB, and <i>then</i> create a new ClassA, passing the ClassB through.<br/>
                            So obviously, this is a little more tedious than newing up a class with no dependencies. But just wait.......
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Class with two dependencies
                            public class ClassA
                            {
                                public ClassA(ClassB classB, ClassC classC) 
                                {
                                    
                                }
                            }
                        </code></pre>
                        <aside class="notes">
                            Let's say now that we have a class with two dependencies... This is what that class would look like.....
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Newing up a class with two dependencies
                            var classB = new ClassB();
                            var classC = new ClassC();
                            var classA = new ClassA(classB, classC);
                        </code></pre>
                        <aside class="notes">
                            And again, this is how you would create a new instance of it...
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Newing up a class with n dependencies
                            var classB = new ClassB();
                            var classC = new ClassC();
                            .
                            .
                            .
                            var classN = new ClassN();

                            var classA = new ClassA(classB, classC, ..., classN);
                        </code></pre>
                        <aside class="notes">
                            Let's say that ClassA has N number of dependencies. That would look similar to this. That's a lot of dependencies.
                        </aside>
                    </section>
                    <section>
                        Multiple Dependencies with Dependencies
                        <aside class="notes">
                            Let's not forget to mention that all of these dependencies could have classes that they are dependent on as well. This can get absolutely absurd.
                        </aside>
                    </section>
                    <section>
                        So what's the <b>problem</b>?
                        <aside class="notes">
                            Well, if you haven't zeroed in on the problem yet, here it is...
                            <br/>
                            Newing up a ton of classses to pass into another is a ton of code, right?
                            <br/>
                            <i>That</i> is the problem with Dependency Injection.
                            <br/>
                            In other words, the problem with Dependency Injection is that it doesn't scale well with multiple dependencies.
                        </aside>
                    </section>
                </section>
                
                <section>
                    <section>
                        <b>The Solution</b>
                        <aside class="notes">
                            So now that we understand the problem, what's the solution?
                        </aside>
                    </section>
                    <section>
                        Don't do it yourself.
                        <aside class="notes">
                            The answer to this is simple, don't do it yourself. Instead, you should automate the process.
                        </aside>
                    </section>
                    <section>
                        So how do you automate the process?
                        <aside class="notes">
                            So at this point you're probably wondering 'How do I automate this process?'. Well, you should be using a Dependency Injection framework.
                        </aside>
                    </section>
                    <section>
                        Dependency Injection Frameworks
                        <aside class="notes">
                        So what is a Dependency Injection framework?
                        <br/>
                        It's a library that provides the tools necessary to easily automate the process of instantiating and injecting classes into other classes.
                        <br/>
                        So what does that really mean?
                        <br/>
                        Basically, a DI framework is a library that automates DI.
                        </aside>
                    </section>
                    <section>
                        More on Frameworks..
                        <aside class="notes">
                            So we have two pretty important questions here: How do DI frameworks work? and How do DI frameworks help me?
                        </aside>
                    </section>
                    <section>
                        How do Dependency Injection frameworks work?
                        <aside class="notes">
                            <ol>
                                <li>To start off, you need to configure your framwork within your code.</li>
                                <li>We'll get more into configuration later, but the important thing to know here is that you're telling the framework what to use and when to use it.</li>
                                <li>Once you configure your framework, when you spin your app up, all classes that you registered will get newed up and put into what's called a Dependency Injection container.</li>
                                <li>From there, you're able to pull any class that's in your container out at any time and use it, as opposed to having to new one up wherever you need it.</li>
                                <li>Those are the very basics of how a DI framework functions.</li>
                            </ol>
                        </aside>
                    </section>
                    <section>
                        What do Dependency Injection frameworks do for you?
                        <aside class="notes">
                            <li>Dependency Injection frameworks do all the heavy lifting for you.</li>
                            <li>Where you would normally have to go in and new up all of your classes all over the place, DI frameworks do that automatically, based on conventions.</li>
                            <li>Frameworks make your code more maintainable because you no longer have to new up classes everywhere, thereby creating dependencies. 
                                They also allow you to write unit tests with ease, because you're now able to pass in a mocked or faked class instead of the real deal.</li>
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        Dependency Injection Frameworks
                        <aside class="notes">
                            Let's take a look at some of the most common Dependency Injection frameworks in the .NET world.
                        </aside>
                    </section>
                    <section>
                        <b>Common Dependency Injection Frameworks</b><br /><br />
                        <span class="fragment">Simple Injector</span><br />
                        <span class="fragment">StructureMap</span><br />
                        <span class="fragment">Castle Windsor</span><br />
                        <span class="fragment">Spring.NET</span><br />
                        <span class="fragment">Autofac</span><br />
                        <span class="fragment">Ninject</span><br />
                        <span class="fragment">Unity</span><br />
                        <aside class="notes">
                            These are some of the most common Dependency Injection frameworks in .NET. And we're actually going to be looking into a few of them to see just how they work.
                        </aside>
                    </section>
                    <section>
                        <b>The Frameworks</b><br /><br />
                        <span class="fragment">Ninject</span><br />
                        <span class="fragment">StructureMap</span><br />
                        <span class="fragment">Simple Injector</span>
                        <aside class="notes">
                            These are the frameworks we will be going through today. We're going to walk through what you need to do to set them up and start using them with your code base.
                        </aside>
                    </section>
                    <section>
                        Using a Dependency Injection Framework
                        <aside class="notes">
                            So before we get started with specific frameworks, let's establish a basis.<br/>
                            To use a DI Framework, you have to do two things. You have to configure it, and then you have to use it. Sounds pretty simple, right? That's because it is.
                        </aside>
                    </section>
                </section>

                <!--Ninject-->

                <section>
                    <section>
                        <b>Ninject</b>
                        <aside class="notes">
                            So let's go ahead and get started with Ninject.
                        </aside>
                    </section>
                    <section>
                        Add Ninject to your project.<br/>
                        <span class="fragment">ninject.org</span>
                        <aside class="notes">
                            First things first, you'll need to download and add Ninject into your code base. You can find it at ninject.org.
                        </aside>
                    </section>
                    <section>
                        Configuration
                        <aside class="notes">
                            So like I said earlier, the first step to setting up a Dependency Injection framework is configuring it.<br/>
                            To configure Ninject we need to find the application's entry point and add some code to tell it what to do.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public class DependencyInjection : NinjectModule
                            {
                                public override void Load()
                                {
                                    Bind&lt;IClassA&gt;().To&lt;ClassA&gt;();
                                }
                            }
                        </code></pre>
                        <aside class="notes">
                            Once you've located the entry point and added Ninject, this is what you're going to add to your code. It's a new class that you'll be using to register your classes to the DI container. 
                            Now, inside that class, you'll need to add this method that let's you tell Ninject what to add and to what interfaces.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            var kernel = new StandardKernel();
                            kernel.Load(Assembly.GetExecutingAssembly());
                        </code></pre>
                        <aside class="notes">
                            Once you've added that class, you can now add some code directly to the entry point. The code for Ninject looks like this. This basically sets up your container for future use in the application.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                        var classA = kernel.Get&lt;IClassA&gt;();
                        </code></pre>
                        <aside class="notes">
                            Now, you can easily reach out to the container and grab an instance of any class that has been registered.
                        </aside>
                    </section>
                    <section>
                        Put It To Use
                        <aside class="notes">
                            So that was step one, the configuration. Now, we have to do step two, which we know is to actually use the container. There are a few different Dependency Injection patterns, but one of the most common ones is called Constructor Injection, and that's what we'll be looking at today.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                        private IClassA _classA;
                        public ClassA(IClassA classA)
                        {
                            _classA = classA;
                        }
                        </code></pre>
                        <aside class="notes">
                            To make use of constructor injection, we need to add a parameter to the constructor of the class we want to inject the dependency into. We'll also add a global varibale outside of the constructor so we can capture the instance and use it throughout the class.                      
                        </aside>
                    </section>
                    <section>
                        That's It
                        <aside class="notes">
                            That's all there is to setting up Ninject, and it's a pretty similar process for other Dependency Injection frameworks.
                        </aside>
                    </section>
                </section>

                <!--StructureMap-->

                <section>
                    <section>
                        <b>StructureMap</b>
                    </section>
                </section>

                <!--SimpleInjector-->

                <section>
                    <section>
                        <b>Simple Injector</b>        
                    </section>
                </section>

                <section>
                    <section>
                        Questions
                    </section>
                    <section>
                        <b>Twitter:</b> @ty8356<br/>
                        <br/>
                        <b>Github Repo:</b> www.github.com/ty8356/DIForNoobs
                    </section>
                </section>

                <section>
                    Thanks!!
                </section>

			</div>
		</div>
		<script>
			Reveal.initialize({
				history: true,
				dependencies: [
					{ src: 'reveal/plugin/markdown/marked.js' },
					{ src: 'reveal/plugin/markdown/markdown.js' },
					{ src: 'reveal/plugin/notes/notes.js', async: true },
					{ src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
