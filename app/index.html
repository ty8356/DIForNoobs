<!doctype html>
<html>
	<head>
		<title>DI For Noobs</title>
		<link rel="stylesheet" href="reveal/css/reveal.css">
		<link rel="stylesheet" href="reveal/css/theme/night.css">
		<link rel="stylesheet" href="reveal/lib/css/zenburn.css">
        <script src="reveal/lib/js/head.min.js"></script>
		<script src="reveal/js/reveal.js"></script>

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal/css/print/pdf.css' : 'reveal/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal" style="font-size: 38px;">
			<div class="slides">

                <section>
                    <h3>Dependency Injection for Noobs</h3>
                    <hr/>
                    Tyler Stephenson
                </section>
                
                <section>
                    <section>
                        <b>About Me</b>
                    </section>
                    <section>
                        <p>
                            Junior Associate .NET Developer at KiZAN Technologies
                            <br/>
                            <br/>
                            <br/>
                            Programming for almost two years
                        </p>
                        <aside class="notes">
                            (September 2015)
                        </aside>
                    </section>
                    <section>
                        <b>Find me on Twitter!</b><br/>
                        @ty8356
                    </section>
                </section>

                <section>
                    <section>
                        So my boss told me to learn about <b>Dependency Injection</b> because it allows for more <b>decoupled code</b>...
                    </section>
                    <section>
                        <p>Why the heck would I want to do that???
                        <br/>
                        <br/>
                        <div class="fragment">And what is Dependency Injection anyway???</div></p>
                    </section>
                    <section>
                        This will be specific to <b>.NET</b> using <b>C#</b>, but these ideas can be used elsewhere. 
                        <aside class="notes">
                            This presentation will be directed specifically at Dependency Injection in .NET using C#, but you can take these ideas and use them in most other frameworks and languages.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        So we've got a <b>problem</b>...
                        <aside class="notes">
                            So we have a problem... And I'm going to show you how to fix that problem... let's get started.
                            <br />
                            So there is a problem with Dependency Injection. But before we actually get into that problem, I want to make sure you have some kind of foundation of <i>what</i> Dependency Injection really is.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        Before we get into <b>Dependency Injection</b>, you need to know a couple things...
                        <aside class="notes">
                            Before we get into Dependency Injection, you have to know a couple things.
                            <br />
                            So, there are a couple of things you need to know before we get into dependency injection.
                        </aside>
                    </section>
                    <section>
                        <b>Interfaces<br/><br/>
                        <span class="fragment">Inversion of Control</b></span>
                        <aside class="notes">
                            Interfaces - What they are, how to use them, and how they can help you.
                            IoC - What it is, how to use it, how it can help you.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <b>Interfaces</b>
                    </section>
                    <section>
                        Programming to <b>interfaces</b> is good.
                        <aside class="notes">
                            So <b>why</b> is programming to an interface so good? What do I mean by that. Well, using interfaces can make your life easier.
                        </aside>
                    </section>
                    <section>
                        Allows you to <b>swap</b> classes in and out.<br/>
                        <span class="fragment">Simplifies <b>unit</b> and <b>integration</b> testing.</span><br/>
                        <span class="fragment">Makes code <b>versatile</b>.</span>
                        <aside class="notes">
                            Programming to an interface is good because it allows you to swap classes in and out based on application needs. 
                            Interfaces also allow for easier unit and integration testing, as you can swap the real class out for a mocked version.
                            Similar to a contract. By implementing an interface, you <b>must</b> have all functions defined.
                        </aside>
                    </section>
                    <section>
                        Let's look at an example...
                    </section>
                    <section>
                        This is an interface...
                        <span class="fragment"><pre><code data-trim data-noescape>
                            public interface InterfaceA
                            {
                                void A(string param);
                                int B();
                            }    
                        </code></pre></span>
                    </section>
                    <section>
                        ... and this is a class <b>implementing</b> that interface.
                        <span class="fragment"><pre><code data-trim data-noescape>
                            public class ClassA : InterfaceA
                            {
                                public void A(string param)
                                {
                                    // Code here
                                }

                                public int B()
                                {
                                    // Code here
                                }
                            }    
                        </code></pre></span>
                    </section>
                    <section>
                        How would I really use this?
                        <aside class="notes">
                            Talk about a personal experience.
                            This leads us to Inversion of Control, or IoC...
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <b>Inversion of Control</b>
                    </section>
                    <section>
                        Let's jump straight into some code...
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public void TestMethod()
                            {
                                string a = "Hello, world!";
                                // More code here
                            }
                        </code></pre>
                        <aside class="notes">
                            Let's say you have a function that does something like this. So we're clearly creating a new string called a and then potentially using it later on.
                            This isn't an incorrect thing to do. However, doing it this way could be really controlling with what exact string is being used.
                            It removes your ability to use any other string in place of the one you've created here. Inversion of Control can help us out with this.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public void TestMethod(string a)
                            {
                                // Code here
                            }
                        </code></pre>
                        <aside class="notes">
                            Here's virtually the same thing again, but this time we're using Inversion of Control. Now, we're giving whoever is calling the function the 
                            ability and the permission to pass through any string they can think of. This makes it the callers responsibility, and gives us the option of using a different string 
                            easily later down the road. 
                        </aside>
                    </section>
                    <section>
                        IoC <b>inverts</b> the <b>control</b>, so that the person calling the class can define how the class works.
                        <aside class="notes">
                            Basically, you can think of Inversion of Control as literally inverting the control to outside of the class. So whoever is calling the class, gets to decide how the class works.
                        </aside>
                    </section>
                    <section>
                        Dependency Injection
                        <aside class="notes">
                            This brings us to Dependency Injection.....<br/>
                            Now, whether you believe it or not, what we've just seen is actually <b>Dependency Injection</b>.<br/>
                            Let's take another look at what DI looks like..
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            var msg = "Hello, world!";
                            MethodA(msg);
                        </code></pre>
                        <aside class="notes">
                            Does this look familiar? This is what Dependency Injection looks like in code.<br/>
                            It's literally the act of passing a parameter into a class.<br/>
                            You are literally injecting the dependency by passing it through as a parameter, so now msg IS a dependency of MethodA.<br/>
                            We could even go as far as calling it Parameter Passing instead of Dependency Injection.<br/>
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        Let's dive deeper...
                        <aside class="notes">
                            So now that you know all of this stuff, let's dive a little deeper into Dependency Injection...
                        </aside>
                    </section>
                    <section>
                        A Different Look at DI.
                        <aside class="notes">
                            So far, we've looked at DI on a function level, passing variables into functions and what not.. Although this IS a form of DI, normally when you hear the 
                            term Dependency Injection, it's actually in reference to passing variables into <i>classes</i>, not functions.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            var msg = "Hello, world!";
                            var testService = new TestService(msg);
                        </code></pre>
                        <aside class="notes">
                            Notice that we're actually passing the msg variable into the class when we new it up!
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public TestService(string msg)
                            {
                                // Code here
                            }
                        </code></pre>
                        <aside class="notes">
                            On the other side of things, the class is capturing that variable in the constructor.
                            Because the constructor takes a string of msg, it now has a <b>dependency</b>, because it depends on that string being passed through.
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        Interfaces, Inversion of Control, and Dependency Injection together.
                        <aside class="notes">
                            So let's take a look at everything we've seen so far, Interfaces, DI, and IoC working together to get a better picture of how we'll be using them in the future. 
                        </aside>
                    </section>
                    <section>
                        
                    </section>
                </section>
                
                <section>
                    <section>
                        <b>The Problem</b>
                        <aside class="notes">
                            Now.......... we can finally get to that problem we teased earlier....<br/>
                            So this whole inversion of control/dependency injection thing is great, right? We're able to reverse the responsibility to the outside of our class. What's not to love? 
                        </aside>
                    </section>
                    <section>
                        Multiple Dependencies
                        <aside class="notes">
                            Well, the problem comes in when we start to have multiple dependencies. Let's take a look at some examples.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Class with no dependencies
                            public class ClassA
                            {
                                public ClassA()
                                {

                                }
                            }
                        </code></pre>
                        <aside class="notes">
                            So let's start from square one. This is a class that has no dependencies. Just your plain old class, doing nothing special.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Newing up a class with no dependencies
                            var classA = new ClassA();
                        </code></pre>
                        <aside class="notes">
                            And newing this class up would look a little something like this. Because it has no dependencies, we don't need to worry about passing anything into it.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Class with a single dependency
                            public class ClassA
                            {
                                public ClassA(ClassB classB) 
                                {
                                    
                                }
                            }
                        </code></pre>
                        <aside class="notes">
                            Now, let's, again, look at a class with a single dependency, to refresh our minds.
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Newing up a class with a single dependency
                            var classB = new ClassB();
                            var classA = new ClassA(classB);
                        </code></pre>
                        <aside class="notes">
                            So here, you can see that you have to create a new ClassB, and <i>then</i> create a new ClassA, passing the ClassB through.<br/>
                            So obviously, this is a little more tedious than newing up a class with no dependencies. But just wait.......
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Class with two dependencies
                            public class ClassA
                            {
                                public ClassA(ClassB classB, ClassC classC) 
                                {
                                    
                                }
                            }
                        </code></pre>
                        <aside class="notes">
                            Let's say now that we have a class with two dependencies... This is what that class would look like.....
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Newing up a class with two dependencies
                            var classB = new ClassB();
                            var classC = new ClassC();
                            var classA = new ClassA(classB, classC);
                        </code></pre>
                        <aside class="notes">
                            And again, this is how you would create a new instance of it...
                        </aside>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            // Newing up a class with n dependencies
                            var classB = new ClassB();
                            var classC = new ClassC();
                            .
                            .
                            .
                            var classN = new ClassN();

                            var classA = new ClassA(classB, classC, ..., classN);
                        </code></pre>
                        <aside class="notes">
                            Let's say that ClassA has N number of dependencies. That would look similar to this. That's a lot of dependencies.
                        </aside>
                    </section>
                    <section>
                        Multiple Dependencies with Dependencies
                        <aside class="notes">
                            Let's not forget to mention that all of these dependencies could have classes that they are dependent on as well. This can get absolutely absurd.
                        </aside>
                    </section>
                    <section>
                        So what's the <b>problem</b>?
                        <aside class="notes">
                            Well, if you haven't zeroed in on the problem yet, here it is...
                            <br/>
                            Newing up a ton of classses to pass into another is a ton of code, right?
                            <br/>
                            <i>That</i> is the problem with Dependency Injection.
                            <br/>
                            In other words, the problem with Dependency Injection is that it doesn't scale well with multiple dependencies.
                        </aside>
                    </section>
                </section>
                
                <section>
                    <section>
                        <b>The Solution</b>
                        <aside class="notes">
                            So now that we understand the problem, what's the solution?
                        </aside>
                    </section>
                    <section>
                        Don't do it yourself.
                        <aside class="notes">
                            The answer to this is simple, don't do it yourself. Instead, you should automate the process.
                        </aside>
                    </section>
                    <section>
                        So how do you automate the process?
                        <aside class="notes">
                            So at this point you're probably wondering 'How do I automate this process?'. Well, you should be using a Dependency Injection framework.
                        </aside>
                    </section>
                    <section>
                        Dependency Injection Frameworks
                        <aside class="notes">
                        So what is a Dependency Injection framework?
                        <br/>
                        It's a library that provides the tools necessary to easily automate the process of instantiating and injecting classes into other classes.
                        <br/>
                        So what does that really mean?
                        <br/>
                        Basically, a DI framework is a library that automates DI.
                        </aside>
                    </section>
                    <section>
                        More on Frameworks..
                        <aside class="notes">
                            So we have two pretty important questions here: How do DI frameworks work? and How do DI frameworks help me?
                        </aside>
                    </section>
                    <section>
                        How do Dependency Injection frameworks work?
                        <aside class="notes">
                            <ol>
                                <li>To start off, you need to do two things to make use of a DI framework. Number one is you need to configure it. Number two is you need to use it.</li>
                                <li>We'll get more into configuration later, but the important thing to know here is that you're telling the framework what to use and when to use it.</li>
                            </ol>
                        </aside>
                    </section>
                    <section>
                        What do Dependency Injection frameworks do for you?
                        <aside class="notes">
                            
                        </aside>
                    </section>
                </section>

                <!--<section>
                    <section>
                        <b>The Solution</b>
                        <aside class="notes">
                            So what's the solution?
                        </aside> 
                    </section>
                    <section>
                        Dependency Injection Containers
                        <aside class="notes">
                            Assuming you don't want to just grit your teeth and go at it the hard way, you can use something called a <b>DI Container</b>.
                        </aside>
                    </section>
                    <section>
                        A <b>DI Container</b> is a software library that provides DI functionality.
                    </section>
                    <section>
                        As opposed to doing all the hard work yourself (<b>Poor Man's DI</b>), you can use a container that does it for you.
                    </section>
                    <section>
                        In the .NET world, a lot of these containers come through <b>Nuget packages</b>, so they're relatively easy to pull down and configure.
                    </section>
                    <section>
                        A few of the most common DI Containers are...
                    </section>
                    <section>
                        StructureMap<br/>
                        <span class="fragment">Castle Windsor</span><br/>
                        <span class="fragment">Spring.NET</span><br/>
                        <span class="fragment">Autofac</span><br/>
                        <span class="fragment">Ninject</span><br/>
                        <span class="fragment">Unity</span>
                    </section>
                </section>-->

                <section>
                    <section>
                        How do I <b>implement</b> these containers??
                    </section>
                    <section>
                        Let's step through how to use a few...
                    </section>
                    <section>
                        Before we begin, let's establish a starting point.
                    </section>
                    <section>
                        I'll be demonstrating this through an MVC Web Application using Visual Studio 2017.
                    </section>
                    <section>
                        So we have a solution in Visual Studio with two projects.<br/>
                        <span class="fragment"><b>Web</b>, the MVC project...</span><br/>
                        <span class="fragment">and <b>Data</b>, a C# class library.</span>
                    </section>
                    <section>
                        In the <b>Data</b> project, there's a interface called <b>IFooService</b> and a class that inherits it called <b>FooService</b>.
                        <span class="fragment"><pre><code data-trim data-noescape>
                            public interface IFooService
                            {
                                string SayHello();
                            }
                        </code></pre>
                        <pre><code data-trim data-noescape>
                            public class FooService : IFooService
                            {
                                public string SayHello()
                                {
                                    var message = "Hello from FooService!"
                                    return message;
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        In the <b>Web</b> project, we have a controller called <b>BarController</b>, along with <b>BarViewModel</b> class and a view called <b>Bar</b>.
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public class BarController : Controller
                            {
                                public ActionResult Index()
                                {
                                    var fooService = new Data.FooService();
                                    var message = fooService.SayHello();
                                    var viewModel = new BarViewModel {Message = message};

                                    return View(viewModel);
                                }
                            }
                        </code></pre>
                        <pre><code data-trim data-noescape>
                            public class BarViewModel
                            {
                                public string Message { get; set; }
                            }
                        </code></pre>
                        <pre><code data-trim>
                            @model BarViewModel

                            <p>Message: @Model.Message</p>
                        </code></pre>
                    </section>
                    <section>
                        As you can see, <b>BarController</b> is newing up a FooService, giving it a dependency that can't be swapped out.
                    </section>
                    <section>
                        So let's learn how to implement some DI containers to correct this.
                    </section>
                </section>

                <!-- Begin Ninject -->
                
                <section>
                    <section>
                        First, let's take a look at <b>Ninject</b>.
                    </section>
                    <section>
                        To get started, you'll have to download the necessary Nuget packages.
                    </section>
                    <section>
                        The Nuget packages we'll need are...
                    </section>
                    <section>
                        Ninject<br/>
                        <span class="fragment">Ninject.Web.Common</span><br/>
                        <span class="fragment">Ninject.MVC5</span>
                    </section>
                    <section>
                        Now for some configuration.
                    </section>
                    <section>
                        Ninject adds a class for you in the <b>App_Start</b> folder called <b>NinjectWebCommon</b>.
                    </section>
                    <section>
                        Open that class and at the bottom there should be a function that looks like this...
                        <span class="fragment"><pre><code data-trim>
                            private static void RegisterServices(IKernel kernel)
                            {
                            }  
                        </code></pre></span>
                    </section>
                    <section>
                        To register <b>IFooService</b>, we can add this line within the function...
                        <span class="fragment"><pre><code data-trim>
                            kernel.Bind&lt;Interface&gt;().To&lt;Class&gt;();
                        </code></pre></span>
                    </section>
                    <section>
                        The finished function should look like this.
                        <span class="fragment"><pre><code data-trim>
                            private static void RegisterServices(IKernel kernel)
                            {
                                kernel.Bind&lt;IFooService&gt;().To&lt;FooService&gt;();
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        This is telling Ninject to grab the pre-instantiated instance of <b>FooService</b> whenever it sees <b>IFooService</b> as the parameter in a classes constructor.
                    </section>
                    <section>
                        Next, we can head over to BarController and change some things...
                    </section>
                    <section>
                        Since we've configured Ninject correctly, we can add a constructor, like so, taking a fooService parameter of type IFooService.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                public BarController(IFooService fooService)
                                {

                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        Like we saw earlier, this is <b>Inversion of Control</b>.
                    </section>
                    <section>
                        Now, since an instance of FooService is being passed to the constructor, we have to capture it somehow to use throughout the class.
                    </section>
                    <section>
                        To do this we can add a private variable to the top of the class and set it equal to the instance being passed into the constructor.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                private IFooService _fooService;

                                public BarController(IFooService fooService)
                                {
                                    _fooService = fooService;
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        Now, we can use the _fooService variable throughout the class, in place of newing up a <b>FooService</b>.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                private IFooService _fooService;

                                public BarController(IFooService fooService)
                                {
                                    _fooService = fooService;
                                }

                                public ActionResult Index()
                                {
                                    var message = _fooService.SayHello();
                                    var viewModel = new BarViewModel {Message = message};

                                    return View(viewModel);
                                }
                            }
                        </code></pre></span>
                    </section>
                </section>
                
                <!-- Begin StructureMap -->
                
                <section>
                    <section>
                        Next up, <b>StructureMap</b>.
                    </section>
                    <section>
                        Once again, you'll need to download the Nuget packages.
                    </section>
                    <section>
                        The Nuget packages we'll need are...
                    </section>
                    <section>
                        StructureMap<br/>
                        <span class="fragment">StructureMap.web</span><br/>
                        <span class="fragment">StructureMap.MVC5.Update</span>
                    </section>
                    <section>
                        And on to the configuration...
                    </section>
                    <section>
                        StructureMap automatically adds a folder called 'DependencyResolution' in the root of your project.
                    </section>
                    <section>
                        The most important class in here to get started is the DefaultRegistry class.<br/>
                        <span class="fragment">This is where you can configure what classes should be registered to what interfaces.</span>
                    </section>
                    <section>
                        It should look something like this.
                        <span class="fragment"><pre><code data-trim data-noescape>
                            public class DefaultRegistry : Registry {
                                public DefaultRegistry() {
                                    Scan(
                                        scan => {
                                            scan.TheCallingAssembly();
                                            scan.WithDefaultConventions();
                                            scan.With(new ControllerConvention();
                                        });
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        To register the <b>IFooService</b> class, we need to add a line of code here, and the syntax is very readable.
                        <span class="fragment"><pre><code data-trim>
                            For&lt;Interface&gt;().Use&lt;Class&gt;();
                        </code></pre></span>
                    </section>
                    <section>
                        The finished class should look like this.
                        <span class="fragment"><pre><code data-trim>
                            public class DefaultRegistry : Registry {
                                public DefaultRegistry() {
                                    Scan(
                                        scan => {
                                            scan.TheCallingAssembly();
                                            scan.WithDefaultConventions();
                                            scan.With(new ControllerConvention();
                                        });
                                    For&lt;IFooService&gt;().Use&lt;FooService&gt;();
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        Over in BarController...
                    </section>
                    <section>
                        Let's add a constructor, taking in a fooService parameter of type IFooService.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                public BarController(IFooService fooService)
                                {

                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        To capture the instance of FooService, we can do the same as with Ninject.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                private IFooService _fooService;

                                public BarController(IFooService fooService)
                                {
                                    _fooService = fooService;
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        Using the _fooService variable throughout the class.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                private IFooService _fooService;

                                public BarController(IFooService fooService)
                                {
                                    _fooService = fooService;
                                }

                                public ActionResult Index()
                                {
                                    var message = _fooService.SayHello();
                                    var viewModel = new BarViewModel {Message = message};

                                    return View(viewModel);
                                }
                            }
                        </code></pre></span>
                    </section>
                </section>

                <!-- Begin SimpleInjector -->

                <section>
                    <section>
                        And lastly, we'll go through <b>Simple Injector</b>.
                    </section>
                    <section>
                        As always, grab the Nuget packages...
                    </section>
                    <section>
                        SimpleInjector<br/>
                        <span class="fragment">SimpleInjector.Integration.Web</span>
                        <span class="fragment">SimpleInjector.Integration.Web.Mvc</span>
                    </section>
                    <section>
                        Simple Injector doesn't actually generate any code <i>for</i> you, but it's still extremely easy to implement.
                    </section>
                    <section>
                        First, you need to go into <b>Global.asax</b> and add a new function with the configuration code.
                        <span class="fragment"><pre><code data-trim data-noescape>
                            protected void InitializeSimpleInjector()
                            {
                                var container = new Container();
                                container.Options.DefaultScopedLifestyle = new WebRequestLifestyle();

                                container.Register&lt;IFooService, FooService&gt;(Lifestyle.Scoped);

                                container.RegisterMvcControllers(Assembly.GetExcecutingAssembly());
                                container.Verify();

                                DependencyResolver
                                    .SetResolver(new SimpleInjectorDependencyResolver(container));
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        And then call that function at the end of the <b>Application_Start</b> function.
                        <span class="fragment"><pre><code data-trim data-noescape>
                            protected void Application_Start()
                            {
                                AreaRegistration.RegisterAllAreas();
                                FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
                                RouteConfig.RegisterRoutes(RouteTable.Routes);
                                BundleConfig.RegisterBundles(BundleTable.Bundles);
                                InitializeSimpleInjector();
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        Now that that's done, we can alter the controller just like we did in the previous two examples.
                    </section>
                    <section>
                        Add the constructor, as well as the private _fooService variable.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                private IFooService _fooService;

                                public BarController(IFooService fooService)
                                {
                                    _fooService = fooService;
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        And then use that variable throughout the class.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                private IFooService _fooService;

                                public BarController(IFooService fooService)
                                {
                                    _fooService = fooService;
                                }

                                public ActionResult Index()
                                {
                                    var message = _fooService.SayHello();
                                    var viewModel = new BarViewModel {Message = message};

                                    return View(viewModel);
                                }
                            }
                        </code></pre></span>
                    </section>
                </section>

                <section>
                    <section>
                        And that's it! 
                    </section>
                    <section>
                        We've just walked through how to implement <b>Ninject</b>, <b>StructureMap</b>, and <b>Simple Injector</b> in an MVC web application.
                    </section>
                    <section>
                        There are other ways of configuring each of these containers that you may get into eventually.
                    </section>
                    <section>
                        This is just the beginning.
                    </section>
                </section>

                <section>
                    <section>
                        Questions
                    </section>
                    <section>
                        <b>Twitter:</b> @ty8356<br/>
                        <br/>
                        <b>Github Repo:</b> www.github.com/ty8356/DIForNoobs
                    </section>
                </section>

                <section>
                    Thanks!!
                </section>

			</div>
		</div>
		<script>
			Reveal.initialize({
				history: true,
				dependencies: [
					{ src: 'reveal/plugin/markdown/marked.js' },
					{ src: 'reveal/plugin/markdown/markdown.js' },
					{ src: 'reveal/plugin/notes/notes.js', async: true },
					{ src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
