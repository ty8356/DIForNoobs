<!doctype html>
<html>
	<head>
		<title>DI For Noobs</title>
		<link rel="stylesheet" href="reveal/css/reveal.css">
		<link rel="stylesheet" href="reveal/css/theme/night.css">
		<link rel="stylesheet" href="reveal/lib/css/zenburn.css">
        <script src="reveal/lib/js/head.min.js"></script>
		<script src="reveal/js/reveal.js"></script>

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal/css/print/pdf.css' : 'reveal/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal" style="font-size: 38px;">
			<div class="slides">

                <section>
                    <h3>Dependency Injection for Noobs</h3>
                    <hr/>
                    Tyler Stephenson
                </section>
                
                <section>
                    <section>
                        <b>About Me</b>
                    </section>
                    <section>
                        <p>
                            Junior Associate .NET Developer at KiZAN Technologies
                            <br/>
                            <br/>
                            <br/>
                            Programming for almost two years
                        </p>
                        <aside class="notes">
                            (September 2015)
                        </aside>
                    </section>
                    <section>
                        <b>Find me on Twitter!</b><br/>
                        @ty8356
                    </section>
                </section>

                <section>
                    <section>
                        Let's get to the good stuff...
                    </section>
                    <section>
                        So my boss told me to learn about <b>Dependency Injection</b> because it allows for more <b>decoupled code</b>...
                    </section>
                    <section>
                        <p>Why the heck would I want to do that???
                        <br/>
                        <br/>
                        <div class="fragment">And what is Dependency Injection anyway???</div></p>
                    </section>
                    <section>
                        This presentation will be directed specifically at Dependency Injection in .NET using C#, but you can take these ideas and use them in most other frameworks and languages.
                    </section>
                    <section>
                        Before we get into answering the specifics, we should take a few steps back.
                    </section>
                </section>

                <section>
                    <section>
                        Let's start off with the <b>problem</b> and where it stems from...
                    </section>
                    <section>
                        It's generally accepted that programming to an <b>interface</b> is a good practice to get into.
                    </section>
                    <section>
                        This allows you to swap classes in and out based on the situation without breaking anything within the application.
                    </section>
                    <section>
                        As long as the class meets the <b>requirements</b> of the interface and the functions return the expected results, everything just works.
                    </section>
                    <section>
                        Let's take a look at an example...
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public class Foo
                            {
                                public Foo(IDatabasePersister db) 
                                {
                                    // some code here
                                }
                            }    
                        </code></pre>
                        <pre><code data-trim data-noescape>
                            public interface IDatabasePersister
                            {
                                Object GetItemById();
                                void Create();
                                void Read();
                                void Update();
                                void Delete();
                            }    
                        </code></pre>
                    </section>
                    <section>
                        Writing your application in this way allows you to use any type of data storage, as long as you write a class that conforms to the interface.
                    </section>
                    <section>
                        This is a <b>huge advantage</b>, especially when writing large business applications.
                    </section>
                </section>

                <section>
                    <section>
                        This structure, passing an interface to the constructor, is known as <b>Inversion of Control</b>, or <b>IoC</b>.
                    </section>
                    <section>
                        <b>Inversion of Control</b> is a software development technique in which you allow the person <b>calling</b> the class to select a concrete implementation type, as opposed to selecting one <b>yourself</b>.
                    </section>
                    <section>
                        You're literally <b>inverting</b> the control.
                    </section>
                    <section>
                        Let's take a look at IoC in <b>code</b>...
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public class Foo
                            {
                                public Foo(IDatabasePersister db) 
                                {
                                    // some code here
                                }
                            }   
                        </code></pre>
                        <pre><code data-trim data-noescape>
                            public class Bar
                            {
                                public void DoStuff()
                                {
                                    var db = new Database();
                                    var foo = new Foo(db);
                                }
                            }
                        </code></pre>
                        <span class="fragment">Notice that the <b>IDatabasePersister</b> interface is now a <b>dependency</b> of Foo.</span>
                    </section>
                    <section>
                        This is because you <b>must</b> pass an instance of <b>IDatabasePersister</b> through when calling the class.
                    </section>
                    <section>
                        This form of <b>IoC</b> is known as <B>Dependency Injection (DI)</b> because you are <b>injecting</b> the dependency into the class through the constructor.
                    </section>
                    <section>
                        <b>Dependency Injection</b> is a set of software design principles and patterns that enable us to develop loosely couled code.
                    </section>
                </section>

                <section>
                    <section>
                        So what's the <b>problem</b> with Inversion of Control using Dependency Injection?
                    </section>
                    <section>
                        Well, when a class has <b>multiple dependencies</b>, things start to get pretty crazy...
                    </section>
                    <section>
                        For example...
                    </section>
                    <section>
                        So we've seen how to inject a single dependency into a class.
                        <span class="fragment"><pre><code data-trim data-noescape>
                            public class Foo 
                            {
                                public Foo(IDatabasePersister db)
                                {
                                    // code here
                                }
                            }
                        </code></pre>
                        <pre><code data-trim data-noescape>
                            public class Bar
                            {
                                public void DoStuff()
                                {
                                    var db = new Database();
                                    var foo = new Foo(db);
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        But what if there are two dependencies?
                        <span class="fragment"><pre><code data-trim data-noescape>
                            public class Foo 
                            {
                                public Foo(IDatabasePersister db, IProductService productService)
                                {
                                    // code here
                                }
                            }
                        </code></pre>
                        <pre><code data-trim data-noescape>
                            public class Bar
                            {
                                public void DoStuff()
                                {
                                    var db = new Database();
                                    var productService = new ProductService();
                                    var foo = new Foo(db, productService);
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        Five?
                        <span class="fragment"><pre><code data-trim data-noescape>
                            public class Foo 
                            {
                                public Foo(IDatabasePersister db, IProductService productService, 
                            ICartService cartService, IPriceService priceService, IDiscountService 
                            discountService)
                                {
                                    // code here
                                }
                            }
                        </code></pre>
                        <pre><code data-trim data-noescape>
                            public class Bar
                            {
                                public void DoStuff()
                                {
                                    var db = new Database();
                                    var productService = new ProductService();
                                    var cartService = new CartService();
                                    var priceService = new PriceService();
                                    var discountService = new DiscountService();
                                    var foo = new Foo(db, productService, cartService, priceService, 
                            discountService);
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        And what if the <b>dependencies</b> have multiple <b>dependencies</b> of their own??
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public class ProductService : IProductService 
                            {
                                public ProductService(ICartService cartService, IPriceService 
                            priceService, IDiscountService discountService)
                                {
                                    // code here
                                }
                            }
                        </code></pre>
                        <pre><code data-trim data-noescape>
                            public class Foo 
                            {
                                public Foo(IDatabasePersister db, IProductService productService)
                                {
                                    // code here
                                }
                            }
                        </code></pre>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public class Bar
                            {
                                public void DoStuff()
                                {
                                    var cartService = new CartService();
                                    var priceService = new PriceService();
                                    var discountService = new DiscountService();
                                    var productService = new ProductService(cartService, priceService,
                            discountService);

                                    var db = new Database();
                                    var foo = new Foo(db, productService);
                                }
                            }
                        </code></pre>
                    </section>
                    <section>
                        As you can see, this can get extremely complex...
                    </section>
                </section>

                <section>
                    <section>
                        So what's the solution?
                    </section>
                    <section>
                        Assuming you don't want to just grit your teeth and go at it the hard way, you can use something called a <b>DI Container</b>.
                    </section>
                    <section>
                        A <b>DI Container</b> is a software library that provides DI functionality.
                    </section>
                    <section>
                        As opposed to doing all the hard work yourself (<b>Poor Man's DI</b>), you can use a container that does it for you.
                    </section>
                    <section>
                        In the .NET world, a lot of these containers come through <b>Nuget packages</b>, so they're relatively easy to pull down and configure.
                    </section>
                    <section>
                        A few of the most common DI Containers are...
                    </section>
                    <section>
                        StructureMap<br/>
                        <span class="fragment">Castle Windsor</span><br/>
                        <span class="fragment">Spring.NET</span><br/>
                        <span class="fragment">Autofac</span><br/>
                        <span class="fragment">Ninject</span><br/>
                        <span class="fragment">Unity</span>
                    </section>
                </section>

                <section>
                    <section>
                        How do I <b>implement</b> these containers??
                    </section>
                    <section>
                        Let's step through how to use a few...
                    </section>
                    <section>
                        Before we begin, let's establish a starting point.
                    </section>
                    <section>
                        I'll be demonstrating this through an MVC Web Application using Visual Studio 2017.
                    </section>
                    <section>
                        So we have a solution in Visual Studio with two projects.<br/>
                        <span class="fragment"><b>Web</b>, the MVC project...</span><br/>
                        <span class="fragment">and <b>Data</b>, a C# class library.</span>
                    </section>
                    <section>
                        In the <b>Data</b> project, there's a interface called <b>IFooService</b> and a class that inherits it called <b>FooService</b>.
                        <span class="fragment"><pre><code data-trim data-noescape>
                            public interface IFooService
                            {
                                string SayHello();
                            }
                        </code></pre>
                        <pre><code data-trim data-noescape>
                            public class FooService : IFooService
                            {
                                public string SayHello()
                                {
                                    var message = "Hello from FooService!"
                                    return message;
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        In the <b>Web</b> project, we have a controller called <b>BarController</b>, along with <b>BarViewModel</b> class and a view called <b>Bar</b>.
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
                            public class BarController : Controller
                            {
                                public ActionResult Index()
                                {
                                    var fooService = new Data.FooService();
                                    var message = fooService.SayHello();
                                    var viewModel = new BarViewModel {Message = message};

                                    return View(viewModel);
                                }
                            }
                        </code></pre>
                        <pre><code data-trim data-noescape>
                            public class BarViewModel
                            {
                                public string Message { get; set; }
                            }
                        </code></pre>
                        <pre><code data-trim>
                            @model BarViewModel

                            <p>Message: @Model.Message</p>
                        </code></pre>
                    </section>
                    <section>
                        As you can see, <b>BarController</b> is newing up a FooService, giving it a dependency that can't be swapped out.
                    </section>
                    <section>
                        So let's learn how to implement some DI containers to correct this.
                    </section>
                </section>

                <!-- Begin Ninject -->
                
                <section>
                    <section>
                        First, let's take a look at <b>Ninject</b>.
                    </section>
                    <section>
                        To get started, you'll have to download the necessary Nuget packages.
                    </section>
                    <section>
                        The Nuget packages we'll need are...
                    </section>
                    <section>
                        Ninject<br/>
                        <span class="fragment">Ninject.MVC5</span>
                    </section>
                    <section>
                        Now for some configuration.
                    </section>
                    <section>
                        Ninject adds a class for you in the <b>App_Start</b> folder called <b>NinjectWebCommon</b>.
                    </section>
                    <section>
                        Open that class and at the bottom there should be a function that looks like this...
                        <span class="fragment"><pre><code data-trim>
                            private static void RegisterServices(IKernel kernel)
                            {
                            }  
                        </code></pre></span>
                    </section>
                    <section>
                        To register <b>IFooService</b>, we can add this line within the function...
                        <span class="fragment"><pre><code data-trim>
                            kernel.Bind&lt;Interface&gt;().To&lt;Class&gt;();
                        </code></pre></span>
                    </section>
                    <section>
                        The finished function should look like this.
                        <span class="fragment"><pre><code data-trim>
                            private static void RegisterServices(IKernel kernel)
                            {
                                kernel.Bind&lt;IFooService&gt;().To&lt;FooService&gt;();
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        This is telling Ninject to grab the pre-instantiated instance of <b>FooService</b> whenever it sees <b>IFooService</b> as the parameter in a classes constructor.
                    </section>
                    <section>
                        Next, we can head over to BarController and change some things...
                    </section>
                    <section>
                        Since we've configured Ninject correctly, we can add a constructor, like so, taking a fooService parameter of type IFooService.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                public BarController(IFooService fooService)
                                {

                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        Like we saw earlier, this is <b>Inversion of Control</b>.
                    </section>
                    <section>
                        Now, since an instance of FooService is being passed to the constructor, we have to capture it somehow to use throughout the class.
                    </section>
                    <section>
                        To do this we can add a private variable to the top of the class and set it equal to the instance being passed into the constructor.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                private IFooService _fooService;

                                public BarController(IFooService fooService)
                                {
                                    _fooService = fooService;
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        Now, we can use the _fooService variable throughout the class, in place of newing up a <b>FooService</b>.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                private IFooService _fooService;

                                public BarController(IFooService fooService)
                                {
                                    _fooService = fooService;
                                }

                                public ActionResult Index()
                                {
                                    var message = _fooService.SayHello();
                                    var viewModel = new BarViewModel {Message = message};

                                    return View(viewModel);
                                }
                            }
                        </code></pre></span>
                    </section>
                </section>
                
                <!-- Begin StructureMap -->
                
                <section>
                    <section>
                        Next up, <b>StructureMap</b>.
                    </section>
                    <section>
                        Once again, you'll need to download the Nuget packages.
                    </section>
                    <section>
                        The Nuget packages we'll need are...
                    </section>
                    <section>
                        StructureMap<br/>
                        <span class="fragment">StructureMap.web</span><br/>
                        <span class="fragment">StructureMap.MVC5.Update</span>
                    </section>
                    <section>
                        And on to the configuration...
                    </section>
                    <section>
                        StructureMap automatically adds a folder called 'DependencyResolution' in the root of your project.
                    </section>
                    <section>
                        The most important class in here to get started is the DefaultRegistry class.<br/>
                        <span class="fragment">This is where you can configure what classes should be registered to what interfaces.</span>
                    </section>
                    <section>
                        It should look something like this.
                        <span class="fragment"><pre><code data-trim data-noescape>
                            public class DefaultRegistry : Registry {
                                public DefaultRegistry() {
                                    Scan(
                                        scan => {
                                            scan.TheCallingAssembly();
                                            scan.WithDefaultConventions();
                                            scan.With(new ControllerConvention();
                                        });
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        To register the <b>IFooService</b> class, we need to add only one line of code here, and the syntax is very readable.
                        <span class="fragment"><pre><code data-trim>
                            For&lt;IFooService&gt;().Use&lt;FooService&gt;();
                        </code></pre></span>
                    </section>
                    <section>
                        The finished class should look like this.
                        <span class="fragment"><pre><code data-trim>
                            public class DefaultRegistry : Registry {
                                public DefaultRegistry() {
                                    Scan(
                                        scan => {
                                            scan.TheCallingAssembly();
                                            scan.WithDefaultConventions();
                                            scan.With(new ControllerConvention();
                                        });
                                    For&lt;IFooService&gt;().Use&lt;FooService&gt;();
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        Over in BarController...
                    </section>
                    <section>
                        Let's add a constructor, taking in a fooService parameter of type IFooService.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                public BarController(IFooService fooService)
                                {

                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        To capture the instance of FooService, we can add a private variable to the top of the class and set it equal to the instance being passed into the constructor.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                private IFooService _fooService;

                                public BarController(IFooService fooService)
                                {
                                    _fooService = fooService;
                                }
                            }
                        </code></pre></span>
                    </section>
                    <section>
                        We can use the _fooService variable throughout the class.
                        <span class="fragment"><pre><code data-trim>
                            public class BarController : Controller
                            {
                                private IFooService _fooService;

                                public BarController(IFooService fooService)
                                {
                                    _fooService = fooService;
                                }

                                public ActionResult Index()
                                {
                                    var message = _fooService.SayHello();
                                    var viewModel = new BarViewModel {Message = message};

                                    return View(viewModel);
                                }
                            }
                        </code></pre></span>
                    </section>
                </section>

                <!-- Begin SimpleInjector -->

                <section>
                    <section>
                        And lastly, we'll go through <b>Simple Injector</b>.
                    </section>
                </section>

                <section>
                    Questions
                </section>

                <section>
                    Thanks!!
                </section>

			</div>
		</div>
		<script>
			Reveal.initialize({
				history: true,
				dependencies: [
					{ src: 'reveal/plugin/markdown/marked.js' },
					{ src: 'reveal/plugin/markdown/markdown.js' },
					{ src: 'reveal/plugin/notes/notes.js', async: true },
					{ src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
            Reveal.configure({ slideNumber: 'c/t' });
		</script>
	</body>
</html>
